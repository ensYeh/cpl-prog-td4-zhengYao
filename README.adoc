= Un jeu de carte Chinois très populaire

_NOM1, Prénom1, no_étudiant1, NC1_, _git login_

_NOM2, Prénom2, no_étudiant2, NC2_, _git login_

_GIT url_ 

L'objet de ce mini-projet est de développer le jeu de carte https://boardgamegeek.com/boardgame/70451/zheng-fen[zheng-fen]. qui doit fonctionner en commande en ligne. Le jeux doit permettre de jouer contre deux autres adversaires qui sera assurer par l'ordinateur. Pour cela, vous devez développer des joueurs virtuels. Le joueur virtuel peut jouer comme un enfant (applique une stratégie basique) ou bien connaître certaines stratégies. Le joueur non virtuel (JNV) doit voir le déroulé de la partie dans un terminal (pas d'interface graphique).

Vous devrez respecter les contraintes fonctionnelles et techniques mentionnées ci-dessous.

[IMPORTANT]
====
Vous respecterez les contraintes suivantes:

* Ce mini-projet est à réaliser en Java par groupe de 2 étudiants.
  - les 2 étudiants doivent coopérer à travers un même git. Un des deux étudiants devra permettre à l'autre d'utiliser son git. Chaque utilisateur devra faire au moins un "merge request". 
* Il devra comporter une documentation dans ce git.
  - La documentation devra décrire l'usage de l'application (_manuel utilisateur_) ainsi que la conception du jeu (_manuel technique_).
  - La documentation doit être un fichier `.md` ou `.adoc` et accessible depuis le `git`
* Vous utiliserez `git` en effectuant des commits réguliers comportant des messages informatifs. L'usage des "pull requests" est également exigé, montrant ainsi votre collaboration au sein du groupe. 
* Le _build_ sera assuré par _Maven_ et plus précisément _Maven wrapper_ (déjà intégré dans le projet).
Aucune manipulation en dehors de Maven ne devra être nécessaire.
* La version de Java à utiliser est la https://adoptium.net/[version 17].
* Le _build_ devra intégrer `checkstyle` pour la vérification des règles de codages Google.
Le projet devra donc les respecter.
`checkstyle` devra être exécuté automatiquement durant la phase `validate` du cycle de vie par défaut.
* Des tests unitaires https://junit.org/junit5/docs/current/user-guide/[JUnit 5] (version https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter/5.9.1[_5.9.1_]) devront être disponibles pour la plupart des méthodes développées.
* Un outil de https://fr.wikipedia.org/wiki/Couverture_de_code[_Code Coverage_] devra être intégré au _build_
* Les fonctionnalités du langage Java devront être utilisées au mieux (POO, exceptions, librairie de collections, I/O, …).
* L'application devra pouvoir être exécutée à partir d'un `jar` incluant toutes les dépendances.
====

== Description de l'application à réaliser
* Pour chaque tour du jeu, l'interface:
  - proposera une visualisation en message textuel clair de l'action émise par chaque joueur. Par exemple, une action peut être _"je mets 3 rois suivie de 2 cartes de valeur 8"_.
    - chaque joueur doit s'afficher dans une couleur distinct.  
  - doit vérifier si la phrase est correcte et si sa proposition est valide en répondant de manière très poli "désolé XXX, mais vous n'avez qu'un roi"
  - l'interface doit s'assurer qu'une partie se termine et permettre au joueur qui a gagné de débuter la nouvelle partie.
  - l'interface doit vérifier que le nombre de joueurs est entre 3 et 5.
  - on doit afficher le nombre de cartes de chaque joueur, mais pas les valeurs qui possèdent.
  - pour toutes les actions effectuées par le programme comme par exemple mélange les couleurs, l'interface doit afficher un messages du type, "je viens de ...."

 

== Contraintes à respecter

* Dans ce jeu, un joueur peu décider d'abandonner. Ca doit être un événement rare, mais possible. 
* L'ordre suivant doit être respecté: Le joker est le plus grand, suivie du 2, 1 (as), roi, ... 3.
* On mémorisera l'historique d'une partie dans une collection et stocké dans un fichier.
    - il sera par exemple possible de rejouer une partie.

* Une interface spécifique pourra être proposée pour une aide, voir un bilan du nombre de parties gagne par chacun/
* Une interface spécifique pourra être proposée pour "espionner" pourquoi chaque joueur à jouer tel ou tel carte.

* Vous devez faire au moins un joueur virtuel qui joue comme un enfant.
* Des points bonus seront donné pour ceux qui implémente un moteur un peu plus complexe. Par exemple, je peux jouer 1, 2 ou 3 cartes identiques, mais si j'ai 3 cartes identiques, je peux aussi decider de jouer une par une, ou bien de jouer une suivie de deux etc. Pour vous livrer un secret, les cartes les plus faibles sont les plus difficiles à s'en débarrasser et peuvent clouer un joueur.
   * Toute la problématique dans ce cas et de décider comment "assembler vos cartes" pour optimiser vos chances de tous les débarrasser.



== Références

**Attention**: il existe plusieurs variantes, mais celui de reference est dans le premier lien avec les contraintes ci-dessus.

* Description du jeu:
  - https://boardgamegeek.com/boardgame/70451/zheng-fen
  - https://chrisenvadrouille.wordpress.com/2013/07/05/jour-46-les-regles-dun-jeu-de-cartes-chinois/
  - https://www.pagat.com/climbing/doudizhu.html


* Quelques bibliothèques :
http://fusesource.github.io/jansi/[JAnsi] (couleur dans un terminal),
https://github.com/jline/jline3[JLine] (gestion des saisies)

== Manuel utilisateur

> À compléter de manière exhaustive:
> Comment est gérer les différents utilisateurs ?
> Décrire la technique utiliser pour décider comment les joueurs virtuels décide l'assemblage des cartes. ?
> Y a t il possibilité qu'un joueur change d'assemblage des cartes en cours de parties et dans tout les cas décrire le pourquoi et le comment ? 
> Quelles sont les modifications/extensions à apporter si l'on veut qu'il n'y ai que des joueurs virtuels ?
> Quelles améliorations peut on envisager pour rendre le jeu plus intéressant/performant pour l'utilisateur ?
> Quelles évolutions peut-on envisager ?

== Manuel technique
=== Compiler le projet
.Sous Linux
----
$ ./mvnw package
----

.Sous Windows
----
> mvnw.cmd package
----

=== Exécuter l'application
----
$ java -jar target/zhangyao-1.0.jar
----

> À compléter :
> Comment consulter le rapport de couverture de code par les tests ?
> Quelles bibliothèques ont été utilisées et pourquoi ?
> Quel est le rôle des différentes classes ?
> Quels traitements sont réalisés pour gérer une commande saisie par l'utilisateur ? Donnez un exemple.
> Quelles améliorations peut-on envisager ?
